import 'package:flutter/material.dart';
import 'package:dart_openai/openai.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'dart:io' show Platform;
import 'chatview.dart';
import 'configpage.dart';
import 'theme.dart';
import 'history.dart';
import 'storage.dart';
import 'utils.dart';

void main() => runApp(const MomotalkApp());

class MomotalkApp extends StatelessWidget {
  const MomotalkApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'MomoTalk',
      home: const MainPage(),
      theme: lightTheme,
      darkTheme: darkTheme,
      themeMode: ThemeMode.system,
    );
  }
}

class MainPage extends StatefulWidget {
  const MainPage({super.key});

  @override
  MainPageState createState() => MainPageState();
}

class MainPageState extends State<MainPage> with WidgetsBindingObserver{
  final fn = FocusNode();
  final textController = TextEditingController();
  final scrollController = ScrollController();
  String model = "";
  String prompt = "";
  int lastMsgTime = 0;
  int splitCount = 0;
  bool inputLock = false;
  bool keyboardOn = false;
  List<Message> messages = [
    Message(message: "Sensei你终于来啦！\\我可是个乖乖看家的好孩子哦", type: 1),
  ];

  Future<void> loadPrompt() async {
    prompt = await rootBundle.loadString("assets/prompt.txt");
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    OpenAI.showLogs = true;
    getApiConfigs().then((configs) {
      if (configs.isNotEmpty) {
        OpenAI.baseUrl = configs[0][1];
        OpenAI.apiKey = configs[0][2];
        model = configs[0][3];
      }
    });
    loadPrompt();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    debugPrint(state.toString());
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    if(!Platform.isAndroid){
      return;
    }
    final bottom = WidgetsBinding.instance.platformDispatcher.views.first.viewInsets.bottom;
    if(bottom>10 && !keyboardOn){
      debugPrint("keyboard on");
      keyboardOn = true;
      Future.delayed(const Duration(milliseconds: 200), () => setScrollPercent(1.0));
    } else if(bottom<10 && keyboardOn){
      debugPrint("keyboard off");
      keyboardOn = false;
    }
  }

  double getScrollPercent() {
    final maxScroll = scrollController.position.maxScrollExtent;
    final currentScroll = scrollController.position.pixels;
    final percent = currentScroll / maxScroll;
    debugPrint("scroll percent: $percent");
    return percent;
  }

  void setScrollPercent(double percent) {
    final maxScroll = scrollController.position.maxScrollExtent;
    final currentScroll = maxScroll * percent;
    scrollController.animateTo(currentScroll,
        duration: const Duration(milliseconds: 200), curve: Curves.easeOut);
  }

  void updateConfig(List<String> c){
    OpenAI.baseUrl = c[1];
    OpenAI.apiKey = c[2];
    model = c[3];
    debugPrint("update config: ${c.toString()}");
  }

  void loadHistory(String msg) {
    List<Message> msgs = jsonToMsg(msg);
    setState(() {
      messages.clear();
      messages.addAll(msgs);
    });
    lastMsgTime = 0;
    for(Message m in msgs){
      if(m.type == 4){
        lastMsgTime = int.parse(m.message);
      }
    }
  }

  void updateResponse(String response) {
    setState(() {
      if (messages.last.type != 1) {
        splitCount = 0;
        messages.add(Message(message: response, type: 1));
      } else {
        messages.last.message = response;
      }
    });
    var currentSplitCount = response.split("\\").length;
    if (splitCount != currentSplitCount) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        scrollController.animateTo(scrollController.position.maxScrollExtent,
            duration: const Duration(milliseconds: 100), curve: Curves.easeOut);
      });
      splitCount = currentSplitCount;
    }
  }

  void clearMsg() {
    setState(() {
      messages.clear();
      messages.add(Message(message: "Sensei你终于来啦！\\我可是个乖乖看家的好孩子哦", type: 1));
    });
    lastMsgTime = 0;
  }

  void logMsg(List<OpenAIChatCompletionChoiceMessageModel> msg) {
    for (var m in msg) {
      debugPrint("${m.role}: ${m.content}");
    }
    debugPrint("model: $model");
  }

  void sendMsg() {
    if (inputLock || textController.text.isEmpty) {
      return;
    }
    inputLock = true;
    debugPrint("inputLocked");
    WidgetsBinding.instance.addPostFrameCallback((_) {
      scrollController.animateTo(scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 100), curve: Curves.easeOut);
    });
    if (DateTime.now()
            .difference(DateTime.fromMillisecondsSinceEpoch(lastMsgTime))
            .inMinutes >
        30) {
      messages.add(Message(message: DateTime.now().millisecondsSinceEpoch.toString(), type: 4));
    }
    setState(() {
      messages.add(Message(message: textController.text, type: 2));
    });
    List<OpenAIChatCompletionChoiceMessageModel> msg = [];
    msg.add(OpenAIChatCompletionChoiceMessageModel(
        content: prompt, role: OpenAIChatMessageRole.system));
    for (var m in messages) {
      if (m.type == 1) {
        msg.add(OpenAIChatCompletionChoiceMessageModel(
            content: m.message, role: OpenAIChatMessageRole.assistant));
      } else if (m.type == 2) {
        msg.add(OpenAIChatCompletionChoiceMessageModel(
            content: m.message, role: OpenAIChatMessageRole.user));
      } else if (m.type == 3) {
        msg.add(OpenAIChatCompletionChoiceMessageModel(
            content: m.message, role: OpenAIChatMessageRole.system));
      } else if (m.type == 4) {
        DateTime t = DateTime.fromMillisecondsSinceEpoch(int.parse(m.message));
        const weekday = ["", "一", "二", "三", "四", "五", "六", "日"];
        var timestr =
            "${t.year}年${t.month}月${t.day}日星期${weekday[t.weekday]}"
            "${t.hour.toString().padLeft(2,'0')}:${t.minute.toString().padLeft(2,'0')}:${t.second.toString().padLeft(2,'0')}";
        msg.add(OpenAIChatCompletionChoiceMessageModel(
            content: "下面的对话开始于 $timestr", role: OpenAIChatMessageRole.system));
      }
    }
    logMsg(msg.sublist(1));
    try {
      final chatStream = OpenAI.instance.chat.createStream(
        model: model,
        messages: msg,
      );
      String response = "";
      chatStream.listen(
        (chatStream) {
          final content = chatStream.choices.first.delta.content?.replaceAll("\n", '');
          response += content!;
          //debugPrint(content);
          //debugPrint(response);
          updateResponse(response);
        },
        onDone: () {
          inputLock = false;
          debugPrint("inputUnlocked");
          lastMsgTime = DateTime.now().millisecondsSinceEpoch;
        },
      );
    } catch (e) {
      debugPrint(e.toString());
      inputLock = false;
      debugPrint("inputUnlocked");
      showDialog(
          context: context,
          builder: (BuildContext context) => AlertDialog(
                title: const Text("Error"),
                content: Text(e.toString()),
                actions: [
                  TextButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text("OK"))
                ],
              ));
    }
    textController.clear();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(
          toolbarHeight: 50,
          title: const SizedBox(
              height: 22,
              child: Image(
                  image: AssetImage("assets/momotalk.webp"),
                  fit: BoxFit.scaleDown)),
          flexibleSpace: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: <Color>[Color(0xffff899e), Color(0xfff79bac)],
              ),
            ),
          ),
          actions: <Widget>[
            PopupMenuButton<String>(
              icon: const Icon(
                Icons.close,
                color: Colors.white,
                size: 40,
              ),
              itemBuilder: (context) => [
                const PopupMenuItem(
                  value: 'Clear',
                  child: Text('Clear'),
                ),
                const PopupMenuItem(
                  value: 'Save',
                  child: Text('Save'),
                ),
                const PopupMenuItem(
                  value: 'History',
                  child: Text('History...'),
                ),
                const PopupMenuItem(
                  value: 'Settings',
                  child: Text('Settings...'),
                ),
              ],
              onSelected: (String value) {
                debugPrint('You Clicked $value');
                if (value == 'Clear') {
                  clearMsg();
                } else if (value == 'Save') {
                  addHistory(msgListToJson(messages));
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                    content: Text('已保存'),
                    behavior: SnackBarBehavior.floating,
                    showCloseIcon: true,
                  ));
                } else if (value == 'Settings') {
                  Navigator.push(
                      context,
                      MaterialPageRoute(
                          builder: (context) => ConfigPage(updateFunc: updateConfig)));
                } else if (value == 'History') {
                  showModalBottomSheet(
                      context: context,
                      showDragHandle: true,
                      scrollControlDisabledMaxHeightRatio: 0.9,
                      builder: (BuildContext context) => HistoryPage(updateFunc: loadHistory));
                }
              },
            ),
          ],
        ),
        body: GestureDetector(
          onTap: () {
            fn.unfocus();
          },
          child: Column(
            children: [
              Expanded(
                  child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 7),
                      child: SingleChildScrollView(
                          controller: scrollController,
                          child: ListView.builder(
                            itemCount: messages.length,
                            shrinkWrap: true,
                            physics: const NeverScrollableScrollPhysics(),
                            itemBuilder: (context, index) {
                              final message = messages[index];
                              if (index == 0) {
                                return Column(
                                  children: [
                                    const SizedBox(height: 10),
                                    ChatElement(
                                      message: message.message,
                                      type: message.type,
                                    )
                                  ],
                                );
                              }
                              return ChatElement(
                                  message: message.message, type: message.type);
                            },
                          )))),
              Padding(
                padding: const EdgeInsets.only(left: 12, right: 12, bottom: 12),
                child: Row(
                  children: [
                    Expanded(
                        child: TextField(
                            focusNode: fn,
                            controller: textController,
                            onEditingComplete: () => sendMsg(),
                            decoration: const InputDecoration(
                              border: OutlineInputBorder(),
                              fillColor: Color(0xffff899e),
                              isCollapsed: true,
                              contentPadding: EdgeInsets.symmetric(
                                horizontal: 10,
                                vertical: 8,
                              ),
                              hintText: 'Type a message',
                            ))),
                    const SizedBox(width: 5),
                    ElevatedButton(
                      onPressed: () => sendMsg(),
                      style: ElevatedButton.styleFrom(
                        padding: const EdgeInsets.all(0),
                        backgroundColor: const Color(0xffff899e),
                        foregroundColor: const Color(0xffffffff),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(5),
                        ),
                      ),
                      child: const Text('Send'),
                    )
                  ],
                ),
              )
            ],
          ),
        ));
  }
}
